package "moonbitlang/quickcheck"

import(
  "moonbitlang/core/bigint"
  "moonbitlang/core/buffer"
  "moonbitlang/core/immut/list"
  "moonbitlang/core/quickcheck/splitmix"
  "moonbitlang/quickcheck/feat"
  "moonbitlang/quickcheck/rose"
)

// Values
fn alphabet() -> Gen[Char]

fn[T, U] ap(Gen[(T) -> U], Gen[T]) -> Gen[U]

fn[T] array_with_size(Gen[T], Int) -> Gen[Array[T]]

fn[A : Eq] associative((A, A) -> A) -> ((A, A, A)) -> Bool

fn[T, U] bind(Gen[T], (T) -> Gen[U]) -> Gen[U]

fn[P : Testable] callback(P, Callback) -> Property

fn char_range(Char, Char) -> Gen[Char]

fn[P : Testable] classify(P, Bool, String) -> Property

fn[P : Testable, T : Show] collect(P, T) -> Property

fn[A, B : Eq] commutative((A, A) -> B) -> ((A, A)) -> Bool

fn complete_test(State, Property) -> TestSuccess!TestError

fn[P : Testable] counterexample(P, String) -> Property

fn[A : Eq] distributive_left((A, A) -> A, (A, A) -> A) -> ((A, A, A)) -> Bool

fn[A : Eq] distributive_right((A, A) -> A, (A, A) -> A) -> ((A, A, A)) -> Bool

fn[T] equal_by(Equivalence[T], (T, T) -> Bool) -> Bool

fn[P : Testable] expect_fail(P) -> Property

fn[P : Testable] expect_gave_up(P) -> Property

fn[A, B : Eq] ext_equal((A) -> B, (A) -> B) -> (A) -> Bool

fn failed() -> SingleResult

fn[P : Testable] filter(P, Bool) -> Property

fn find_failure(State, SingleResult, Iter[@rose.Rose[SingleResult]]) -> TestSuccess!TestError

fn[T] flatten_array(Array[Gen[T]]) -> Gen[Array[T]]

fn[T] flatten_list(@list.T[Gen[T]]) -> Gen[@list.T[T]]

fn[T] flatten_option(Gen[T]?) -> Gen[T?]

fn[T, E] flatten_result(Result[Gen[T], E]) -> Gen[Result[T, E]]

fn[T, U] fmap(Gen[T], (T) -> U) -> Gen[U]

fn[T : Testable, A : Show] forall(Gen[A], (A) -> T) -> Property

fn[T : Testable, A : Show] forall_shrink(Gen[A], (A) -> Iter[A], (A) -> T) -> Property

fn format(Printer, String) -> String

fn[T] frequency(Array[(Int, Gen[T])]) -> Gen[T]

fn[T] frequency_list(@list.T[(Int, T)]) -> Gen[T]

fn give_up(State, Property) -> TestSuccess!TestError

fn[A : Eq] idempotent((A) -> A) -> (A) -> Bool

fn ident(Printer, size~ : Int = ..) -> Unit

fn[P : Testable] if_fail(P, () -> Unit) -> Property

fn int_bound(Int) -> Gen[Int]

fn int_range(Int, Int) -> Gen[Int]

fn integer_bound(@bigint.BigInt) -> Gen[@bigint.BigInt]

fn[A : Eq, B] inverse((A) -> B, (B) -> A) -> (A) -> Bool

fn[A : Eq] involutory((A) -> A) -> (A) -> Bool

fn[T : Eq] is_equal(Equivalence[T]) -> Bool

fn[T] join(Gen[Gen[T]]) -> Gen[T]

fn[P : Testable] label(P, String) -> Property

fn[A, B, C] liftA2((A, B) -> C, Gen[A], Gen[B]) -> Gen[C]

fn[A, B, C, D] liftA3((A, B, C) -> D, Gen[A], Gen[B], Gen[C]) -> Gen[D]

fn[A, B, C, D, E] liftA4((A, B, C, D) -> E, Gen[A], Gen[B], Gen[C], Gen[D]) -> Gen[E]

fn[A, B, C, D, E, F] liftA5((A, B, C, D, E) -> F, Gen[A], Gen[B], Gen[C], Gen[D], Gen[E]) -> Gen[F]

fn[A, B, C, D, E, F, G] liftA6((A, B, C, D, E, F) -> G, Gen[A], Gen[B], Gen[C], Gen[D], Gen[E], Gen[F]) -> Gen[G]

fn[T] list_with_size(Int, Gen[T]) -> Gen[@list.T[T]]

fn local_min(State, SingleResult, Iter[@rose.Rose[SingleResult]]) -> (Int, Int, Int, SingleResult)

fn local_min_found(State, SingleResult) -> (Int, Int, Int, SingleResult)

fn[P : Testable] map_size(P, (Int) -> Int) -> Property

fn[P : Testable] map_total_result(P, (SingleResult) -> SingleResult) -> Property

fn[A : Compare, B : Compare] mono_decrease((A) -> B) -> ((A, A)) -> Bool

fn[A : Compare, B : Compare] mono_increase((A) -> B) -> ((A, A)) -> Bool

fn nat() -> Gen[Int]

fn neg_int() -> Gen[Int]

fn numeral() -> Gen[Char]

fn[T] one_of(Array[Gen[T]]) -> Gen[T]

fn[T] one_of_array(Array[T]) -> Gen[T]

fn[T] one_of_list(@list.T[T]) -> Gen[T]

fn[T] pure(T) -> Gen[T]

fn[T] pure_eq(T) -> Equivalence[T]

fn[T, U, V, W] quad(Gen[T], Gen[U], Gen[V], Gen[W]) -> Gen[(T, U, V, W)]

fn[P : Testable] quick_check(P) -> Unit!Failure

fn[A : @moonbitlang/core/quickcheck.Arbitrary + Shrink + Show, B : Testable] quick_check_fn((A) -> B) -> Unit!Failure

fn[P : Testable] quick_check_with(Config, P) -> Unit!Failure

fn[P : Testable] quick_check_with_result(Config, P) -> TestSuccess!TestError

fn rejected() -> SingleResult

fn[T] resize(Gen[T], Int) -> Gen[T]

fn[P : Testable] run_prop(P) -> Gen[@rose.Rose[SingleResult]]

fn run_single_test(State, Property) -> Result[TestSuccess, State]!TestError

fn run_test(State, Property) -> TestSuccess!TestError

fn[T] scale(Gen[T], (Int) -> Int) -> Gen[T]

fn[P : Testable, T] shrinking((T) -> Iter[T], T, (T) -> P) -> Property

fn[T] sized((Int) -> Gen[T]) -> Gen[T]

fn small_int() -> Gen[Int]

fn[T : Compare] sorted_list(Int, Gen[T]) -> Gen[@list.T[T]]

fn succeed() -> SingleResult

fn[T] such_that(Gen[T], (T) -> Bool) -> Gen[T]

fn[T] such_that_maybe(Gen[T], (T) -> Bool) -> Gen[T?]

fn[P : Testable] terminate(P) -> Property

fn[T, U] to_property(Axiom[T], (T) -> U, (U, U) -> Bool) -> (T) -> Bool

fn[T, U : Eq] to_property_eq(Axiom[T], (T) -> U) -> (T) -> Bool

fn[T, M, N] to_property_parametric(Axiom[T], (T, M) -> N, (N, N) -> Bool) -> ((T, M)) -> Bool

fn[T, M, N : Eq] to_property_parametric_eq(Axiom[T], (T, M) -> N) -> ((T, M)) -> Bool

fn[T, U, V] triple(Gen[T], Gen[U], Gen[V]) -> Gen[(T, U, V)]

fn[T, U] tuple(Gen[T], Gen[U]) -> Gen[(T, U)]

fn unident(Printer) -> Unit

fn[P : Testable] with_discarded_ratio(P, Int) -> Property

fn[P : Testable] with_max_shrinks(P, Int) -> Property

fn[P : Testable] with_max_size(P, Int) -> Property

fn[P : Testable] with_max_success(P, Int) -> Property

fn write_string(Printer, String) -> Unit

// Types and methods
pub(all) type Arrow[A, B] (A) -> B
impl[P : Testable, A : @moonbitlang/core/quickcheck.Arbitrary + Shrink + Show] Testable for Arrow[A, P]

type Axiom[T]
impl Axiom {
  new[T]((T) -> Equivalence[T]) -> Self[T]
  run[T](Self[T], T) -> Equivalence[T]
  to_property[T, U](Self[T], (T) -> U, (U, U) -> Bool) -> (T) -> Bool
  to_property_eq[T, U : Eq](Self[T], (T) -> U) -> (T) -> Bool
  to_property_parametric[T, M, N](Self[T], (T, M) -> N, (N, N) -> Bool) -> ((T, M)) -> Bool
  to_property_parametric_eq[T, M, N : Eq](Self[T], (T, M) -> N) -> ((T, M)) -> Bool
}

type Callback

type Config

type Discard
impl Default for Discard
impl Testable for Discard

pub(all) struct Equivalence[T] {
  lhs : T
  rhs : T
}
impl Equivalence {
  ap[T, U](Self[(T) -> U], Self[T]) -> Self[U]
  bind[T, U](Self[T], (T) -> Self[U]) -> Self[U]
  equal_by[T](Self[T], (T, T) -> Bool) -> Bool
  fmap[T, U](Self[T], (T) -> U) -> Self[U]
  is_equal[T : Eq](Self[T]) -> Bool
  new[T](T, T) -> Self[T]
}
impl[T : Show] Show for Equivalence[T]

type Gen[T]
impl Gen {
  ap[T, U](Self[(T) -> U], Self[T]) -> Self[U]
  array_with_size[T](Self[T], Int) -> Self[Array[T]]
  bind[T, U](Self[T], (T) -> Self[U]) -> Self[U]
  feat_random[T : @feat.Enumerable](Int) -> Self[T]
  fmap[T, U](Self[T], (T) -> U) -> Self[U]
  join[T](Self[Self[T]]) -> Self[T]
  new[T]((Int, @splitmix.RandomState) -> T) -> Self[T]
  resize[T](Self[T], Int) -> Self[T]
  run[T](Self[T], Int, @splitmix.RandomState) -> T
  sample[T](Self[T], size~ : Int = .., seed~ : UInt64 = ..) -> T
  samples[T](Self[T], size~ : Int = .., seed~ : UInt64 = ..) -> Array[T]
  scale[T](Self[T], (Int) -> Int) -> Self[T]
  spawn[T : @moonbitlang/core/quickcheck.Arbitrary]() -> Self[T]
  such_that[T](Self[T], (T) -> Bool) -> Self[T]
  such_that_maybe[T](Self[T], (T) -> Bool) -> Self[T?]
}
impl[P : Testable] Testable for Gen[P]

pub(all) enum Outcome[T] {
  Success
  GaveUp
  Fail(T)
}
impl[T] Show for Outcome[T]

type Printer
impl Printer {
  format(Self, String) -> String
  from_buffer(@buffer.T) -> Self
  ident(Self, size~ : Int = ..) -> Unit
  unident(Self) -> Unit
  write_string(Self, String) -> Unit
}

type Property
impl Testable for Property

pub(all) struct Replay {
  rand_state : @splitmix.RandomState
  size : Int
}
impl Replay {
  new(@splitmix.RandomState, Int) -> Self
}

type SingleResult
impl Testable for SingleResult

type State
impl State {
  complete_test(Self, Property) -> TestSuccess!TestError
  find_failure(Self, SingleResult, Iter[@rose.Rose[SingleResult]]) -> TestSuccess!TestError
  give_up(Self, Property) -> TestSuccess!TestError
  local_min(Self, SingleResult, Iter[@rose.Rose[SingleResult]]) -> (Int, Int, Int, SingleResult)
  run_single_test(Self, Property) -> Result[TestSuccess, Self]!TestError
  run_test(Self, Property) -> TestSuccess!TestError
}

type TestError

type TestSuccess

// Type aliases
pub typealias RandomState = @splitmix.RandomState

// Traits
pub(open) trait Shrink {
  shrink(Self) -> Iter[Self] = _
}

pub(open) trait Testable {
  property(Self) -> Property
}
impl Testable for Unit
impl Testable for Bool
impl[P : Testable] Testable for P?
impl Testable for @rose.Rose[SingleResult]

