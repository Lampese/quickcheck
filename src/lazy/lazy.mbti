package "moonbitlang/quickcheck/lazy"

import(
  "moonbitlang/core/immut/list"
)

// Values
fn[T] concat(LazyList[T], LazyList[T]) -> LazyList[T]

fn[X : Default] default() -> LazyList[X]

fn[T] drop(LazyList[T], Int) -> LazyList[T]

fn[T] drop_while(LazyList[T], (T) -> Bool) -> LazyList[T]

fn[T, U] fold_left(LazyList[T], (U, T) -> U, init~ : U) -> U

fn[T, U] fold_right(LazyList[T], (T, U) -> U, init~ : U) -> U

fn[T] force(LazyRef[T]) -> T

fn[T] from_list(@list.T[T]) -> LazyList[T]

fn[T] head(LazyList[T]) -> T

fn[T] index(LazyList[T], Int) -> T

fn[X : Add] infinite_stream(X, X) -> LazyList[X]

fn[T] length(LazyList[T]) -> Int

fn[T, U] map(LazyList[T], (T) -> U) -> LazyList[U]

fn[T] repeat(T) -> LazyList[T]

fn[T] split_at(LazyList[T], Int) -> (LazyList[T], LazyList[T])

fn[X : Add] sum(LazyList[X], init~ : X) -> X

fn[T] tail(LazyList[T]) -> LazyList[T]

fn[T] tails(LazyList[T]) -> LazyList[LazyList[T]]

fn[T] take(LazyList[T], Int) -> LazyList[T]

fn[T] take_while(LazyList[T], (T) -> Bool) -> LazyList[T]

fn[T] to_lazy(@list.T[T]) -> LazyList[T]

fn[T] unfold(LazyList[T], (LazyList[T]) -> (T, LazyList[T])?) -> LazyList[T]

fn[A, B, C] zip_lazy_normal((A, B) -> C, LazyList[A], @list.T[B]) -> @list.T[C]

fn[T] zip_plus((T, T) -> T, LazyList[T], LazyList[T]) -> LazyList[T]

fn[A, B, C] zip_with((A, B) -> C, LazyList[A], LazyList[B]) -> LazyList[C]

// Types and methods
pub(all) enum LazyList[T] {
  Nil
  Cons(T, LazyRef[LazyList[T]])
}
impl LazyList {
  concat[T](Self[T], Self[T]) -> Self[T]
  drop[T](Self[T], Int) -> Self[T]
  drop_while[T](Self[T], (T) -> Bool) -> Self[T]
  fold_left[T, U](Self[T], (U, T) -> U, init~ : U) -> U
  fold_right[T, U](Self[T], (T, U) -> U, init~ : U) -> U
  head[T](Self[T]) -> T
  index[T](Self[T], Int) -> T
  length[T](Self[T]) -> Int
  map[T, U](Self[T], (T) -> U) -> Self[U]
  split_at[T](Self[T], Int) -> (Self[T], Self[T])
  tail[T](Self[T]) -> Self[T]
  tails[T](Self[T]) -> Self[Self[T]]
  take[T](Self[T], Int) -> Self[T]
  take_while[T](Self[T], (T) -> Bool) -> Self[T]
  unfold[T](Self[T], (Self[T]) -> (T, Self[T])?) -> Self[T]
}
impl[T] Add for LazyList[T]
impl[T : Show] Show for LazyList[T]

type LazyRef[T]
impl LazyRef {
  force[T](Self[T]) -> T
  from_thunk[T](() -> T) -> Self[T]
  from_value[T](T) -> Self[T]
}

// Type aliases

// Traits

